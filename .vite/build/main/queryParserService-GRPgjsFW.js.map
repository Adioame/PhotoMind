{"version":3,"file":"queryParserService-GRPgjsFW.js","sources":["../../../electron/services/queryParserService.ts"],"sourcesContent":["/**\n * PhotoMind - 查询解析服务\n *\n * 功能：\n * 1. 调用 LLM 解析用户查询意图\n * 2. 提取结构化搜索参数\n * 3. 识别查询类型\n * 4. 支持规则匹配降级\n */\nimport { getConfigService } from './configService.js'\n\nexport type QueryType = 'keyword' | 'semantic' | 'time' | 'location' | 'people' | 'mixed'\n\nexport interface QueryEntity {\n  type: 'person' | 'time' | 'location' | 'event' | 'object' | 'emotion'\n  value: string\n  confidence: number\n}\n\nexport interface SearchHint {\n  type: 'year' | 'month' | 'place' | 'person' | 'album' | 'keyword'\n  value: string\n}\n\nexport interface QueryIntent {\n  type: QueryType\n  confidence: number\n  entities: QueryEntity[]\n  refinedQuery: string\n  searchHints: SearchHint[]\n}\n\nexport interface QueryParseResult {\n  original: string\n  parsed: QueryIntent\n  timestamp: number\n  fallbackUsed: boolean\n}\n\nexport class QueryParserService {\n  private configService = getConfigService()\n  private cache: Map<string, QueryParseResult> = new Map()\n  private readonly CACHE_TTL = 5 * 60 * 1000 // 5分钟\n  private readonly CACHE_MAX_SIZE = 500\n\n  /**\n   * 解析用户查询\n   */\n  async parse(query: string): Promise<QueryParseResult> {\n    // 1. 检查缓存\n    const cached = this.getCachedResult(query)\n    if (cached) {\n      return cached\n    }\n\n    // 2. 尝试 LLM 解析\n    if (this.configService.isLLMConfigured()) {\n      try {\n        const result = await this.parseWithLLM(query)\n        this.cacheResult(query, result)\n        return result\n      } catch (error) {\n        console.error('[QueryParser] LLM 解析失败，降级到规则匹配', error)\n      }\n    }\n\n    // 3. 降级到规则匹配\n    const result = this.parseWithRules(query)\n    this.cacheResult(query, result)\n    return result\n  }\n\n  /**\n   * 使用 LLM 解析查询\n   */\n  private async parseWithLLM(query: string): Promise<QueryParseResult> {\n    const config = this.configService.getLLMConfig()\n    const prompt = this.buildPrompt(query)\n\n    const response = await this.callLLM(prompt, 3000) // 3秒超时\n\n    if (!response.success) {\n      throw new Error(response.error)\n    }\n\n    return this.parseLLMResponse(query, response.result!)\n  }\n\n  /**\n   * 构建 LLM Prompt\n   */\n  private buildPrompt(query: string): string {\n    return `分析以下照片搜索查询，提取结构化信息：\n\n查询: \"${query}\"\n\n请以 JSON 格式返回分析结果：\n{\n  \"type\": \"keyword|semantic|time|location|people|mixed\",\n  \"confidence\": 0.0-1.0,\n  \"entities\": [\n    {\"type\": \"person|time|location|event|object|emotion\", \"value\": \"具体内容\", \"confidence\": 0.0-1.0}\n  ],\n  \"refinedQuery\": \"优化后的搜索查询\",\n  \"searchHints\": [\n    {\"type\": \"year|month|place|person|album|keyword\", \"value\": \"提示信息\"}\n  ]\n}\n\n只返回 JSON，不要其他内容。`\n  }\n\n  /**\n   * 调用 LLM API\n   */\n  private async callLLM(prompt: string, timeout: number): Promise<{\n    success: boolean\n    result?: string\n    error?: string\n  }> {\n    const config = this.configService.getLLMConfig()\n\n    try {\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() => controller.abort(), timeout)\n\n      const response = await fetch(`${config.baseUrl}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${config.apiKey}`\n        },\n        body: JSON.stringify({\n          model: config.model,\n          messages: [{ role: 'user', content: prompt }],\n          max_tokens: 500,\n          temperature: 0.1\n        }),\n        signal: controller.signal\n      })\n\n      clearTimeout(timeoutId)\n\n      if (!response.ok) {\n        const error = await response.text()\n        return { success: false, error: `API 错误: ${error}` }\n      }\n\n      const data = await response.json() as { choices?: Array<{ message?: { content: string } }> }\n      const content = data.choices?.[0]?.message?.content || ''\n      return { success: true, result: content }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : '未知错误'\n      }\n    }\n  }\n\n  /**\n   * 解析 LLM 响应\n   */\n  private parseLLMResponse(original: string, response: string): QueryParseResult {\n    try {\n      // 尝试解析 JSON\n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/)\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[0])\n        return {\n          original,\n          parsed: {\n            type: parsed.type || 'mixed',\n            confidence: parsed.confidence || 0.5,\n            entities: parsed.entities || [],\n            refinedQuery: parsed.refinedQuery || original,\n            searchHints: parsed.searchHints || []\n          },\n          timestamp: Date.now(),\n          fallbackUsed: false\n        }\n      }\n    } catch (error) {\n      console.error('[QueryParser] JSON 解析失败', error)\n    }\n\n    // 降级\n    return this.parseWithRules(original)\n  }\n\n  /**\n   * 规则匹配解析\n   */\n  private parseWithRules(query: string): QueryParseResult {\n    const lowerQuery = query.toLowerCase()\n    const entities: QueryEntity[] = []\n    const searchHints: SearchHint[] = []\n\n    // 时间模式检测\n    const yearPattern = /(?:在|于|年份)?(\\d{4})年?/\n    const monthPattern = /(\\d{1,2})月/\n    const yearMatch = query.match(yearPattern)\n    const monthMatch = query.match(monthPattern)\n\n    if (yearMatch) {\n      entities.push({\n        type: 'time',\n        value: yearMatch[1],\n        confidence: 0.9\n      })\n      searchHints.push({ type: 'year', value: yearMatch[1] })\n    }\n\n    if (monthMatch) {\n      entities.push({\n        type: 'time',\n        value: `${yearMatch?.[1] || '未知'}-${monthMatch[1]}`,\n        confidence: 0.8\n      })\n      searchHints.push({ type: 'month', value: monthMatch[1] })\n    }\n\n    // 人物模式检测\n    const personPatterns = [\n      { pattern: /(?:和|跟|与|带)\\s*(.+?)\\s*(?:的|合影|照片|图片)/, extract: 1 },\n      { pattern: /(.+?)\\s*(?:妈妈|爸爸|朋友|家人|同事|宝贝)/, extract: 1 },\n      { pattern: /(?:和|跟|与|带)\\s*(.+)/, extract: 1 }\n    ]\n\n    for (const { pattern, extract } of personPatterns) {\n      const match = query.match(pattern)\n      if (match && match[extract]) {\n        const value = match[extract].trim()\n        if (value.length > 0 && value.length < 20) {\n          entities.push({\n            type: 'person',\n            value,\n            confidence: 0.7\n          })\n          searchHints.push({ type: 'person', value })\n          break\n        }\n      }\n    }\n\n    // 地点模式检测\n    const locations = ['日本', '美国', '欧洲', '国内', '北京', '上海', '东京', '纽约', '巴黎', '海边', '山', '城市', '乡村']\n    for (const location of locations) {\n      if (lowerQuery.includes(location)) {\n        entities.push({\n          type: 'location',\n          value: location,\n          confidence: 0.7\n        })\n        searchHints.push({ type: 'place', value: location })\n        break\n      }\n    }\n\n    // 情感词检测\n    const emotionWords = ['好看', '美丽', '漂亮', '温暖', '开心', '快乐', '幸福', '悲伤', '浪漫', '可爱']\n    const hasEmotion = emotionWords.some(word => lowerQuery.includes(word))\n\n    // 确定查询类型\n    let type: QueryType = 'keyword'\n    if (entities.length > 0) {\n      type = 'mixed'\n    } else if (hasEmotion) {\n      type = 'semantic'\n    }\n\n    // 关键词提取\n    const keywords = this.extractKeywords(query)\n\n    return {\n      original: query,\n      parsed: {\n        type,\n        confidence: entities.length > 0 ? 0.8 : 0.5,\n        entities,\n        refinedQuery: keywords.join(' '),\n        searchHints\n      },\n      timestamp: Date.now(),\n      fallbackUsed: true\n    }\n  }\n\n  /**\n   * 提取关键词\n   */\n  private extractKeywords(query: string): string[] {\n    const stopWords = ['的', '是', '在', '和', '与', '跟', '我', '你', '他', '她', '它', '这', '那', '照片', '图片', '影像', '拍摄', '拍']\n    return query\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter(word => word.length > 1 && !stopWords.includes(word))\n  }\n\n  /**\n   * 缓存查询结果\n   */\n  private cacheResult(query: string, result: QueryParseResult): void {\n    this.cache.set(query, result)\n\n    // 限制缓存大小\n    if (this.cache.size > this.CACHE_MAX_SIZE) {\n      // 删除最旧的条目\n      const firstKey = this.cache.keys().next().value as string | undefined\n      if (firstKey) {\n        this.cache.delete(firstKey)\n      }\n    }\n  }\n\n  /**\n   * 获取缓存结果\n   */\n  private getCachedResult(query: string): QueryParseResult | null {\n    const cached = this.cache.get(query)\n    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {\n      return cached\n    }\n    if (cached) {\n      this.cache.delete(query)\n    }\n    return null\n  }\n\n  /**\n   * 清空缓存\n   */\n  clearCache(): void {\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getCacheStats(): { size: number; maxSize: number } {\n    return {\n      size: this.cache.size,\n      maxSize: this.CACHE_MAX_SIZE\n    }\n  }\n}\n\nexport const queryParserService = new QueryParserService()\n"],"names":["result"],"mappings":"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"}
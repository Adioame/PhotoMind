{"version":3,"file":"keywordSearchService-BdTauFmh.js","sources":["../../../electron/services/keywordSearchService.ts"],"sourcesContent":["/**\n * PhotoMind - 关键词搜索服务\n *\n * 功能：\n * 1. 基于文件名的精确/模糊搜索\n * 2. 文件夹路径搜索\n * 3. EXIF/位置元数据搜索\n * 4. 多关键词组合\n * 5. 搜索建议\n */\nimport { PhotoDatabase } from '../database/db.js'\n\nexport interface KeywordSearchOptions {\n  query: string\n  fields?: string[]\n  fuzzy?: boolean\n  limit?: number\n  offset?: number\n}\n\nexport interface KeywordSearchResult {\n  photoUuid: string\n  fileName: string\n  filePath: string\n  matchedField: string\n  matchScore: number\n  highlights: string[]\n}\n\nexport class KeywordSearchService {\n  private database: PhotoDatabase\n\n  constructor(database?: PhotoDatabase) {\n    this.database = database || new PhotoDatabase()\n  }\n\n  /**\n   * 执行关键词搜索\n   */\n  async search(options: KeywordSearchOptions): Promise<{\n    results: KeywordSearchResult[]\n    total: number\n    query: string\n  }> {\n    const {\n      query,\n      fields = ['file_name', 'folder_path', 'exif_data', 'location_data'],\n      fuzzy = true,\n      limit = 50,\n      offset = 0\n    } = options\n\n    // 1. 解析关键词\n    const keywords = this.parseKeywords(query)\n\n    if (keywords.length === 0) {\n      return { results: [], total: 0, query }\n    }\n\n    // 2. 获取所有照片\n    const photos = this.database.getAllPhotos()\n    console.log(`[KeywordSearch] 搜索 ${photos.length} 张照片，关键词: ${keywords.join(', ')}`)\n\n    // 3. 过滤和排序\n    const matched: KeywordSearchResult[] = []\n\n    for (const photo of photos) {\n      const result = this.matchPhoto(photo, keywords, fields, fuzzy)\n      if (result) {\n        matched.push(result)\n      }\n    }\n\n    // 4. 按匹配分数排序\n    matched.sort((a, b) => b.matchScore - a.matchScore)\n\n    // 5. 分页\n    const total = matched.length\n    const pagedResults = matched.slice(offset, offset + limit)\n\n    console.log(`[KeywordSearch] 找到 ${total} 个匹配结果`)\n\n    return {\n      results: pagedResults,\n      total,\n      query\n    }\n  }\n\n  /**\n   * 解析搜索关键词\n   */\n  private parseKeywords(query: string): string[] {\n    return query\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter(k => k.length > 0)\n  }\n\n  /**\n   * 匹配照片\n   */\n  private matchPhoto(\n    photo: any,\n    keywords: string[],\n    fields: string[],\n    fuzzy: boolean\n  ): KeywordSearchResult | null {\n    let bestScore = 0\n    let matchedField = ''\n    let highlights: string[] = []\n\n    for (const field of fields) {\n      const fieldValue = this.getFieldValue(photo, field)\n      if (!fieldValue) continue\n\n      for (const keyword of keywords) {\n        const matchResult = this.matchField(fieldValue, keyword, fuzzy)\n        if (matchResult.match) {\n          const score = this.calculateScore(fieldValue, keyword, field, fuzzy)\n          if (score > bestScore) {\n            bestScore = score\n            matchedField = field\n            highlights = matchResult.highlights\n          }\n        }\n      }\n    }\n\n    if (bestScore > 0) {\n      return {\n        photoUuid: photo.uuid,\n        fileName: photo.file_name,\n        filePath: photo.file_path,\n        matchedField,\n        matchScore: bestScore,\n        highlights\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * 获取字段值\n   */\n  private getFieldValue(photo: any, field: string): string | null {\n    switch (field) {\n      case 'file_name':\n        return photo.file_name?.toLowerCase() || null\n      case 'folder_path':\n        const pathParts = photo.file_path?.split('/') || []\n        return pathParts.slice(0, -1).join('/').toLowerCase() || null\n      case 'exif_data':\n        if (photo.exif_data) {\n          try {\n            const exif = typeof photo.exif_data === 'string'\n              ? JSON.parse(photo.exif_data)\n              : photo.exif_data\n            return JSON.stringify(exif).toLowerCase()\n          } catch {\n            return null\n          }\n        }\n        return null\n      case 'location_data':\n        if (photo.location_data) {\n          try {\n            const loc = typeof photo.location_data === 'string'\n              ? JSON.parse(photo.location_data)\n              : photo.location_data\n            return JSON.stringify(loc).toLowerCase()\n          } catch {\n            return null\n          }\n        }\n        return null\n      default:\n        return null\n    }\n  }\n\n  /**\n   * 匹配字段值\n   */\n  private matchField(\n    fieldValue: string,\n    keyword: string,\n    fuzzy: boolean\n  ): { match: boolean; highlights: string[] } {\n    const highlights: string[] = []\n\n    if (fuzzy) {\n      // 模糊匹配 - 包含匹配\n      if (fieldValue.includes(keyword)) {\n        highlights.push(keyword)\n        return { match: true, highlights }\n      }\n\n      // 相似度匹配\n      if (this.calculateSimilarity(fieldValue, keyword) > 0.6) {\n        highlights.push(keyword)\n        return { match: true, highlights }\n      }\n    } else {\n      // 精确匹配\n      const words = fieldValue.split(/\\W+/)\n      for (const word of words) {\n        if (word === keyword) {\n          highlights.push(keyword)\n          return { match: true, highlights }\n        }\n      }\n    }\n\n    return { match: false, highlights: [] }\n  }\n\n  /**\n   * 计算匹配分数\n   */\n  private calculateScore(\n    fieldValue: string,\n    keyword: string,\n    field: string,\n    fuzzy: boolean\n  ): number {\n    let score = 0\n\n    // 文件名匹配权重最高\n    if (field === 'file_name') {\n      const fileName = fieldValue\n      if (fileName.startsWith(keyword)) {\n        score = 100 // 前缀匹配\n      } else if (fileName.includes(` ${keyword}`) || fileName.includes(`-${keyword}`)) {\n        score = 80 // 单词边界匹配\n      } else if (fileName.includes(keyword)) {\n        score = 50 // 部分匹配\n      } else {\n        score = 25 // 模糊匹配\n      }\n    } else if (field === 'folder_path') {\n      score = 30\n    } else {\n      score = 10 // EXIF/位置 权重较低\n    }\n\n    // 模糊匹配降低分数\n    if (fuzzy && !fieldValue.includes(keyword)) {\n      score *= 0.5\n    }\n\n    return score\n  }\n\n  /**\n   * 计算字符串相似度\n   */\n  private calculateSimilarity(str1: string, str2: string): number {\n    const longer = str1.length > str2.length ? str1 : str2\n    const shorter = str1.length > str2.length ? str2 : str1\n\n    if (longer.length === 0) return 1.0\n\n    const editDistance = this.levenshteinDistance(longer, shorter)\n    return (longer.length - editDistance) / longer.length\n  }\n\n  /**\n   * Levenshtein 距离\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const matrix: number[][] = []\n\n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i]\n    }\n\n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j\n    }\n\n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1]\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1,\n            matrix[i][j - 1] + 1,\n            matrix[i - 1][j] + 1\n          )\n        }\n      }\n    }\n\n    return matrix[str2.length][str1.length]\n  }\n\n  /**\n   * 快速搜索（简化版）\n   */\n  async quickSearch(query: string, limit: number = 20): Promise<KeywordSearchResult[]> {\n    const result = await this.search({\n      query,\n      fuzzy: true,\n      limit,\n      offset: 0\n    })\n    return result.results\n  }\n\n  /**\n   * 获取搜索建议\n   */\n  getSuggestions(query: string, limit: number = 10): string[] {\n    const keywords = this.parseKeywords(query)\n    const photos = this.database.getAllPhotos()\n\n    const suggestions = new Set<string>()\n\n    for (const photo of photos) {\n      // 从文件名提取\n      const fileName = photo.file_name?.toLowerCase() || ''\n\n      for (const keyword of keywords) {\n        // 查找包含关键词的部分\n        const index = fileName.indexOf(keyword)\n        if (index !== -1) {\n          // 提取完整单词\n          const wordMatch = fileName.match(new RegExp(`\\\\w{${index},${index + keyword.length + 10}}`))\n          if (wordMatch) {\n            suggestions.add(wordMatch[0])\n          }\n        }\n      }\n\n      if (suggestions.size >= limit) break\n    }\n\n    return Array.from(suggestions).slice(0, limit)\n  }\n\n  /**\n   * 统计包含关键词的照片数量\n   */\n  countByKeyword(keyword: string): number {\n    const lowerKeyword = keyword.toLowerCase()\n    const photos = this.database.getAllPhotos()\n\n    let count = 0\n    for (const photo of photos) {\n      const fileName = photo.file_name?.toLowerCase() || ''\n      if (fileName.includes(lowerKeyword)) {\n        count++\n      }\n    }\n\n    return count\n  }\n}\n\nexport const keywordSearchService = new KeywordSearchService()\n"],"names":[],"mappings":"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"}
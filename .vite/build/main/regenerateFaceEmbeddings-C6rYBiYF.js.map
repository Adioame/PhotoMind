{"version":3,"file":"regenerateFaceEmbeddings-C6rYBiYF.js","sources":["../../../electron/scripts/regenerateFaceEmbeddings.ts"],"sourcesContent":["/**\n * PhotoMind - 人脸向量重新生成脚本\n *\n * 功能：\n * 1. 批量重新生成所有人脸的 128维 + 512维向量\n * 2. 支持断点续传\n * 3. 后台队列处理\n * 4. 进度追踪\n */\nimport { PhotoDatabase } from '../database/db.js'\nimport { faceDetectionService } from '../services/faceDetectionService.js'\nimport { getEmbeddingService } from '../services/hybridEmbeddingService.js'\nimport { faceMatchingService } from '../services/faceMatchingService.js'\nimport { resolve, dirname } from 'path'\nimport { existsSync, writeFileSync, readFileSync, mkdirSync } from 'fs'\nimport sharp from 'sharp'\n\nexport interface RegenerationProgress {\n  totalFaces: number\n  processedCount: number\n  successCount: number\n  failedCount: number\n  currentFaceId: string | null\n  status: 'idle' | 'running' | 'paused' | 'completed' | 'error'\n  startTime: string | null\n  endTime: string | null\n  errors: Array<{ faceId: string; error: string }>\n}\n\nexport interface RegenerationOptions {\n  batchSize?: number\n  onProgress?: (progress: RegenerationProgress) => void\n  resumeFromCheckpoint?: boolean\n}\n\nconst PROGRESS_FILE = resolve(process.cwd(), 'data/regenerate-progress.json')\n\nexport class FaceEmbeddingRegenerator {\n  private database: PhotoDatabase\n  private progress: RegenerationProgress\n  private isRunning = false\n  private abortController: AbortController | null = null\n\n  constructor(database?: PhotoDatabase) {\n    this.database = database || new PhotoDatabase()\n    this.progress = this.loadProgress()\n  }\n\n  /**\n   * 加载进度文件\n   */\n  private loadProgress(): RegenerationProgress {\n    try {\n      if (existsSync(PROGRESS_FILE)) {\n        const data = readFileSync(PROGRESS_FILE, 'utf-8')\n        return JSON.parse(data)\n      }\n    } catch (error) {\n      console.error('[Regenerator] 加载进度文件失败:', error)\n    }\n\n    return {\n      totalFaces: 0,\n      processedCount: 0,\n      successCount: 0,\n      failedCount: 0,\n      currentFaceId: null,\n      status: 'idle',\n      startTime: null,\n      endTime: null,\n      errors: []\n    }\n  }\n\n  /**\n   * 保存进度到文件\n   */\n  private saveProgress(): void {\n    try {\n      const dir = dirname(PROGRESS_FILE)\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true })\n      }\n      writeFileSync(PROGRESS_FILE, JSON.stringify(this.progress, null, 2))\n    } catch (error) {\n      console.error('[Regenerator] 保存进度失败:', error)\n    }\n  }\n\n  /**\n   * 获取需要重新生成向量的人脸列表\n   */\n  private getFacesToRegenerate(): Array<{\n    id: string\n    photo_id: number\n    file_path: string\n    bbox_x: number\n    bbox_y: number\n    bbox_width: number\n    bbox_height: number\n    confidence: number\n  }> {\n    // 获取所有 vector_version < 2 的人脸\n    const rows = this.database.query(`\n      SELECT df.id, df.photo_id, df.bbox_x, df.bbox_y, df.bbox_width, df.bbox_height, df.confidence, p.file_path\n      FROM detected_faces df\n      JOIN photos p ON df.photo_id = p.id\n      WHERE df.vector_version IS NULL OR df.vector_version < 2\n      ORDER BY df.created_at ASC\n    `)\n\n    return rows.map((row: any) => ({\n      id: row.id,\n      photo_id: row.photo_id,\n      file_path: row.file_path,\n      bbox_x: row.bbox_x,\n      bbox_y: row.bbox_y,\n      bbox_width: row.bbox_width,\n      bbox_height: row.bbox_height,\n      confidence: row.confidence\n    }))\n  }\n\n  /**\n   * 为单个人脸重新生成向量\n   */\n  private async regenerateFaceEmbedding(face: {\n    id: string\n    photo_id: number\n    file_path: string\n    bbox_x: number\n    bbox_y: number\n    bbox_width: number\n    bbox_height: number\n    confidence: number\n  }): Promise<{ success: boolean; error?: string }> {\n    try {\n      // 检查照片文件是否存在\n      if (!existsSync(face.file_path)) {\n        return { success: false, error: '照片文件不存在' }\n      }\n\n      // 获取图片尺寸（用于坐标转换）\n      const imageInfo = await sharp(face.file_path).metadata()\n      const imgWidth = imageInfo.width || 1\n      const imgHeight = imageInfo.height || 1\n\n      // 转换相对坐标为绝对像素坐标（假设原检测使用 416x416）\n      const absX = Math.round((face.bbox_x / 416) * imgWidth)\n      const absY = Math.round((face.bbox_y / 416) * imgHeight)\n      const absWidth = Math.round((face.bbox_width / 416) * imgWidth)\n      const absHeight = Math.round((face.bbox_height / 416) * imgHeight)\n\n      // 确保坐标在图片范围内\n      const cropX = Math.max(0, absX)\n      const cropY = Math.max(0, absY)\n      const cropWidth = Math.min(absWidth, imgWidth - cropX)\n      const cropHeight = Math.min(absHeight, imgHeight - cropY)\n\n      if (cropWidth <= 0 || cropHeight <= 0) {\n        return { success: false, error: '无效的裁剪区域' }\n      }\n\n      // 步骤 1: 使用 face-api 重新检测并生成 128维向量\n      let faceDescriptor: number[] | null = null\n      try {\n        const detectResult = await faceDetectionService.detect(face.file_path)\n        if (detectResult.success && detectResult.detections.length > 0) {\n          // 找到最匹配的人脸（基于 bbox 重叠度）\n          let bestMatch = detectResult.detections[0]\n          let bestIoU = 0\n\n          for (const detection of detectResult.detections) {\n            const iou = this.calculateIoU(\n              { x: face.bbox_x, y: face.bbox_y, width: face.bbox_width, height: face.bbox_height },\n              detection.box\n            )\n            if (iou > bestIoU) {\n              bestIoU = iou\n              bestMatch = detection\n            }\n          }\n\n          // 如果 IoU > 0.5，认为是同一个人脸\n          if (bestIoU > 0.5 && bestMatch.descriptor) {\n            faceDescriptor = bestMatch.descriptor\n          }\n        }\n      } catch (faceApiError) {\n        console.warn(`[Regenerator] face-api 检测失败: ${face.id}`, faceApiError)\n      }\n\n      // 步骤 2: 裁剪人脸区域并使用 CLIP 生成 512维向量\n      let semanticEmbedding: number[] | null = null\n      try {\n        const faceBuffer = await sharp(face.file_path)\n          .extract({ left: cropX, top: cropY, width: cropWidth, height: cropHeight })\n          .resize(224, 224, { fit: 'cover' })\n          .jpeg({ quality: 90 })\n          .toBuffer()\n\n        const faceBase64 = `data:image/jpeg;base64,${faceBuffer.toString('base64')}`\n        const embeddingService = getEmbeddingService()\n        const clipResult = await embeddingService.imageToEmbedding(faceBase64)\n\n        if (clipResult.success && clipResult.vector) {\n          semanticEmbedding = clipResult.vector.values || (clipResult.vector as any)\n        }\n      } catch (clipError) {\n        console.warn(`[Regenerator] CLIP 向量生成失败: ${face.id}`, clipError)\n      }\n\n      // 步骤 3: 更新数据库\n      if (faceDescriptor || semanticEmbedding) {\n        const embeddingBuffer = faceDescriptor\n          ? Buffer.from(new Float32Array(faceDescriptor).buffer)\n          : null\n        const semanticBuffer = semanticEmbedding\n          ? Buffer.from(new Float32Array(semanticEmbedding).buffer)\n          : null\n\n        this.database.run(\n          `UPDATE detected_faces\n           SET embedding = COALESCE(?, embedding),\n               face_embedding = ?,\n               semantic_embedding = ?,\n               vector_version = CASE\n                 WHEN ? IS NOT NULL AND ? IS NOT NULL THEN 2\n                 WHEN ? IS NOT NULL THEN 1\n                 ELSE vector_version\n               END\n           WHERE id = ?`,\n          [\n            embeddingBuffer,\n            embeddingBuffer,\n            semanticBuffer,\n            semanticBuffer, // for CASE WHEN ? IS NOT NULL\n            embeddingBuffer, // for CASE WHEN ? IS NOT NULL\n            embeddingBuffer, // for CASE WHEN ? IS NOT NULL\n            face.id\n          ]\n        )\n\n        return { success: true }\n      }\n\n      return { success: false, error: '未能生成任何向量' }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : '未知错误'\n      }\n    }\n  }\n\n  /**\n   * 计算两个边界框的 IoU (Intersection over Union)\n   */\n  private calculateIoU(box1: { x: number; y: number; width: number; height: number },\n                       box2: { x: number; y: number; width: number; height: number }): number {\n    const x1 = Math.max(box1.x, box2.x)\n    const y1 = Math.max(box1.y, box2.y)\n    const x2 = Math.min(box1.x + box1.width, box2.x + box2.width)\n    const y2 = Math.min(box1.y + box1.height, box2.y + box2.height)\n\n    const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1)\n    const area1 = box1.width * box1.height\n    const area2 = box2.width * box2.height\n    const union = area1 + area2 - intersection\n\n    return union > 0 ? intersection / union : 0\n  }\n\n  /**\n   * 开始重新生成任务\n   */\n  async start(options: RegenerationOptions = {}): Promise<RegenerationProgress> {\n    if (this.isRunning) {\n      throw new Error('重新生成任务已在进行中')\n    }\n\n    const { batchSize = 50, onProgress, resumeFromCheckpoint = true } = options\n\n    this.isRunning = true\n    this.abortController = new AbortController()\n\n    // 如果需要，重置进度\n    if (!resumeFromCheckpoint) {\n      this.progress = {\n        totalFaces: 0,\n        processedCount: 0,\n        successCount: 0,\n        failedCount: 0,\n        currentFaceId: null,\n        status: 'running',\n        startTime: new Date().toISOString(),\n        endTime: null,\n        errors: []\n      }\n    } else {\n      this.progress.status = 'running'\n      if (!this.progress.startTime) {\n        this.progress.startTime = new Date().toISOString()\n      }\n    }\n\n    // 获取需要处理的人脸\n    const facesToProcess = this.getFacesToRegenerate()\n    this.progress.totalFaces = facesToProcess.length\n\n    console.log(`[Regenerator] 开始重新生成 ${facesToProcess.length} 张人脸的向量`)\n\n    // 分批处理\n    for (let i = 0; i < facesToProcess.length; i += batchSize) {\n      if (this.abortController?.signal.aborted) {\n        console.log('[Regenerator] 任务已取消')\n        this.progress.status = 'paused'\n        break\n      }\n\n      const batch = facesToProcess.slice(i, i + batchSize)\n\n      for (const face of batch) {\n        if (this.abortController?.signal.aborted) {\n          break\n        }\n\n        this.progress.currentFaceId = face.id\n\n        try {\n          const result = await this.regenerateFaceEmbedding(face)\n\n          if (result.success) {\n            this.progress.successCount++\n          } else {\n            this.progress.failedCount++\n            this.progress.errors.push({ faceId: face.id, error: result.error || '未知错误' })\n          }\n        } catch (error) {\n          this.progress.failedCount++\n          this.progress.errors.push({\n            faceId: face.id,\n            error: error instanceof Error ? error.message : '未知错误'\n          })\n        }\n\n        this.progress.processedCount++\n\n        // 每处理 10 张保存一次进度\n        if (this.progress.processedCount % 10 === 0) {\n          this.saveProgress()\n          console.log(`[Regenerator] 进度: ${this.progress.processedCount}/${this.progress.totalFaces}`)\n        }\n\n        // 报告进度\n        onProgress?.({ ...this.progress })\n\n        // 每批处理后释放内存\n        if (global.gc) {\n          global.gc()\n        }\n      }\n    }\n\n    // 任务完成或暂停\n    if (this.progress.status !== 'paused') {\n      this.progress.status = this.progress.failedCount === 0 ? 'completed' : 'error'\n      this.progress.endTime = new Date().toISOString()\n    }\n\n    this.progress.currentFaceId = null\n    this.saveProgress()\n    this.isRunning = false\n\n    console.log(`[Regenerator] 任务结束: 成功 ${this.progress.successCount}, 失败 ${this.progress.failedCount}`)\n\n    return this.progress\n  }\n\n  /**\n   * 取消/暂停任务\n   */\n  pause(): void {\n    if (this.isRunning) {\n      this.abortController?.abort()\n      this.progress.status = 'paused'\n      this.saveProgress()\n      console.log('[Regenerator] 任务已暂停')\n    }\n  }\n\n  /**\n   * 获取当前进度\n   */\n  getProgress(): RegenerationProgress {\n    return { ...this.progress }\n  }\n\n  /**\n   * 重置进度（用于重新开始）\n   */\n  reset(): void {\n    this.progress = {\n      totalFaces: 0,\n      processedCount: 0,\n      successCount: 0,\n      failedCount: 0,\n      currentFaceId: null,\n      status: 'idle',\n      startTime: null,\n      endTime: null,\n      errors: []\n    }\n    this.saveProgress()\n  }\n\n  /**\n   * 执行重新聚类\n   */\n  async recluster(): Promise<{\n    success: boolean\n    clustersCreated: number\n    personsCreated: number\n    error?: string\n  }> {\n    try {\n      console.log('[Regenerator] 开始重新聚类...')\n\n      // 清除现有人物关联\n      this.database.run('UPDATE detected_faces SET person_id = NULL, processed = 0')\n      console.log('[Regenerator] 已清除人物关联')\n\n      // 执行聚类\n      const result = await faceMatchingService.autoMatch({\n        threshold: 0.6,\n        onProgress: (current, total) => {\n          if (current % 100 === 0) {\n            console.log(`[Regenerator] 聚类进度: ${current}/${total}`)\n          }\n        }\n      })\n\n      console.log(`[Regenerator] 聚类完成: ${result.personsCreated} 个人物, ${result.matched} 张人脸已匹配`)\n\n      return {\n        success: true,\n        clustersCreated: result.clusters.length,\n        personsCreated: result.personsCreated || 0\n      }\n    } catch (error) {\n      console.error('[Regenerator] 聚类失败:', error)\n      return {\n        success: false,\n        clustersCreated: 0,\n        personsCreated: 0,\n        error: error instanceof Error ? error.message : '未知错误'\n      }\n    }\n  }\n\n  /**\n   * 清理空人物\n   */\n  cleanupEmptyPersons(): { deleted: number } {\n    try {\n      // 获取所有 face_count = 0 的人物\n      const emptyPersons = this.database.query(`\n        SELECT p.id\n        FROM persons p\n        LEFT JOIN detected_faces df ON p.id = df.person_id\n        GROUP BY p.id\n        HAVING COUNT(df.id) = 0\n      `)\n\n      let deleted = 0\n      for (const person of emptyPersons) {\n        this.database.run('DELETE FROM persons WHERE id = ?', [person.id])\n        deleted++\n      }\n\n      console.log(`[Regenerator] 清理了 ${deleted} 个空人物`)\n      return { deleted }\n    } catch (error) {\n      console.error('[Regenerator] 清理空人物失败:', error)\n      return { deleted: 0 }\n    }\n  }\n}\n\n// 导出单例\nexport const faceEmbeddingRegenerator = new FaceEmbeddingRegenerator()\n"],"names":[],"mappings":"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"}
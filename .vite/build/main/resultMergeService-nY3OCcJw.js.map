{"version":3,"file":"resultMergeService-nY3OCcJw.js","sources":["../../../electron/services/resultMergeService.ts"],"sourcesContent":["/**\n * PhotoMind - 结果融合服务\n *\n * 功能：\n * 1. 融合关键词和向量搜索结果\n * 2. 结果去重和加权排序\n * 3. 意图感知的权重调整\n * 4. 结果重新排序\n */\nimport { KeywordSearchResult, keywordSearchService } from './keywordSearchService.js'\nimport { GlobalSearchResult, globalSearchService } from './globalSearchService.js'\nimport { QueryIntent, queryParserService } from './queryParserService.js'\nimport { PhotoDatabase } from '../database/db.js'\n\nexport interface MergedSearchOptions {\n  query: string\n  queryIntent?: QueryIntent\n  keywordWeight?: number\n  vectorWeight?: number\n  limit?: number\n  minScore?: number\n  enableDeduplication?: boolean\n}\n\nexport interface MergedSearchResult {\n  photoUuid: string\n  fileName: string\n  filePath: string\n  score: number\n  rank: number\n  sources: SearchSource[]\n  highlights: string[]\n  thumbnailPath?: string\n  takenAt?: string\n}\n\nexport interface SearchSource {\n  type: 'keyword' | 'semantic'\n  score: number\n  weight: number\n  weightedScore: number\n}\n\nexport interface MergedSearchResponse {\n  results: MergedSearchResult[]\n  total: number\n  query: string\n  intent?: QueryIntent\n  processingTimeMs: number\n  stats: {\n    keywordCount: number\n    semanticCount: number\n    mergedCount: number\n  }\n}\n\nexport class ResultMergeService {\n  private keywordWeight = 0.3\n  private vectorWeight = 0.7\n  private database: PhotoDatabase\n\n  constructor(database?: PhotoDatabase) {\n    this.database = database || new PhotoDatabase()\n  }\n\n  /**\n   * 执行混合搜索（融合关键词和向量搜索）\n   */\n  async search(options: MergedSearchOptions): Promise<MergedSearchResponse> {\n    const startTime = Date.now()\n    const {\n      query,\n      queryIntent,\n      keywordWeight = this.keywordWeight,\n      vectorWeight = this.vectorWeight,\n      limit = 50,\n      minScore = 0.1,\n      enableDeduplication = true\n    } = options\n\n    // 更新权重\n    this.keywordWeight = keywordWeight\n    this.vectorWeight = vectorWeight\n\n    console.log(`[ResultMerge] 开始混合搜索: \"${query}\"`)\n\n    // 1. 并行执行两种搜索\n    const [keywordResults, semanticResults] = await Promise.all([\n      this.keywordSearch(query),\n      this.semanticSearch(query)\n    ])\n\n    console.log(`[ResultMerge] 关键词搜索: ${keywordResults.length}, 向量搜索: ${semanticResults.length}`)\n\n    // 2. 融合结果\n    const merged = this.mergeResults(\n      keywordResults,\n      semanticResults,\n      keywordWeight,\n      vectorWeight,\n      enableDeduplication\n    )\n\n    // 3. 过滤和排序\n    const filtered = merged\n      .filter(r => r.score >= minScore)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n\n    // 4. 设置排名\n    filtered.forEach((r, i) => r.rank = i + 1)\n\n    // 5. 丰富结果\n    await this.enrichResults(filtered)\n\n    const processingTime = Date.now() - startTime\n    console.log(`[ResultMerge] 融合完成，返回 ${filtered.length} 个结果，耗时 ${processingTime}ms`)\n\n    return {\n      results: filtered,\n      total: filtered.length,\n      query,\n      intent: queryIntent,\n      processingTimeMs: processingTime,\n      stats: {\n        keywordCount: keywordResults.length,\n        semanticCount: semanticResults.length,\n        mergedCount: filtered.length\n      }\n    }\n  }\n\n  /**\n   * 执行混合搜索（带意图解析）\n   */\n  async searchWithIntent(query: string): Promise<MergedSearchResponse> {\n    // 1. 解析查询意图\n    const parseResult = await queryParserService.parse(query)\n    const intent = parseResult.parsed\n\n    console.log(`[ResultMerge] 查询意图: ${intent.type}, 置信度: ${intent.confidence}`)\n\n    // 2. 根据意图调整权重\n    let keywordWeight = 0.3\n    let vectorWeight = 0.7\n\n    switch (intent.type) {\n      case 'keyword':\n        keywordWeight = 0.7\n        vectorWeight = 0.3\n        break\n      case 'semantic':\n        keywordWeight = 0.2\n        vectorWeight = 0.8\n        break\n      case 'people':\n      case 'location':\n      case 'time':\n        keywordWeight = 0.5\n        vectorWeight = 0.5\n        break\n    }\n\n    // 3. 执行混合搜索\n    return this.search({\n      query,\n      queryIntent: intent,\n      keywordWeight,\n      vectorWeight,\n      limit: 50,\n      enableDeduplication: true\n    })\n  }\n\n  /**\n   * 关键词搜索\n   */\n  private async keywordSearch(query: string): Promise<KeywordSearchResult[]> {\n    try {\n      const result = await keywordSearchService.search({\n        query,\n        fuzzy: true,\n        limit: 100\n      })\n      return result.results\n    } catch (error) {\n      console.error('[ResultMerge] 关键词搜索失败:', error)\n      return []\n    }\n  }\n\n  /**\n   * 向量搜索\n   */\n  private async semanticSearch(query: string): Promise<GlobalSearchResult[]> {\n    try {\n      const result = await globalSearchService.search({\n        query,\n        topK: 100,\n        minSimilarity: 0.1\n      })\n      return result.results\n    } catch (error) {\n      console.error('[ResultMerge] 向量搜索失败:', error)\n      return []\n    }\n  }\n\n  /**\n   * 融合结果\n   */\n  private mergeResults(\n    keywordResults: KeywordSearchResult[],\n    semanticResults: GlobalSearchResult[],\n    keywordWeight: number,\n    vectorWeight: number,\n    enableDeduplication: boolean\n  ): MergedSearchResult[] {\n    const scoreMap = new Map<string, MergedSearchResult>()\n\n    // 处理关键词结果\n    for (const item of keywordResults) {\n      const normalizedScore = this.normalizeKeywordScore(item.matchScore)\n      const weightedScore = normalizedScore * keywordWeight\n\n      scoreMap.set(item.photoUuid, {\n        photoUuid: item.photoUuid,\n        fileName: item.fileName,\n        filePath: item.filePath,\n        score: weightedScore,\n        rank: 0,\n        sources: [{\n          type: 'keyword',\n          score: normalizedScore,\n          weight: keywordWeight,\n          weightedScore\n        }],\n        highlights: item.highlights\n      })\n    }\n\n    // 处理向量结果\n    for (const item of semanticResults) {\n      const normalizedScore = this.normalizeVectorScore(item.similarity)\n      const weightedScore = normalizedScore * vectorWeight\n\n      const existing = scoreMap.get(item.photoUuid)\n      if (existing) {\n        // 合并来源\n        existing.sources.push({\n          type: 'semantic',\n          score: normalizedScore,\n          weight: vectorWeight,\n          weightedScore\n        })\n        // 更新总分\n        existing.score = this.calculateTotalScore(existing.sources)\n        // 合并高亮\n        const existingHighlights = existing.highlights || []\n        const itemHighlights = item.highlights || []\n        existing.highlights = [...new Set([...existingHighlights, ...itemHighlights])]\n      } else {\n        scoreMap.set(item.photoUuid, {\n          photoUuid: item.photoUuid,\n          fileName: item.fileName,\n          filePath: item.filePath,\n          score: weightedScore,\n          rank: 0,\n          sources: [{\n            type: 'semantic',\n            score: normalizedScore,\n            weight: vectorWeight,\n            weightedScore\n          }],\n          highlights: item.highlights || []\n        })\n      }\n    }\n\n    // 返回去重后的结果\n    if (enableDeduplication) {\n      return Array.from(scoreMap.values())\n    }\n\n    return Array.from(scoreMap.values())\n  }\n\n  /**\n   * 标准化关键词分数 (0-1)\n   */\n  private normalizeKeywordScore(matchScore: number): number {\n    return Math.min(matchScore / 100, 1)\n  }\n\n  /**\n   * 标准化向量分数 (0-1)\n   */\n  private normalizeVectorScore(similarity: number): number {\n    return Math.min(Math.max(similarity, 0), 1)\n  }\n\n  /**\n   * 计算总分\n   */\n  private calculateTotalScore(sources: SearchSource[]): number {\n    return sources.reduce((total, source) => total + source.weightedScore, 0)\n  }\n\n  /**\n   * 丰富结果\n   */\n  private async enrichResults(results: MergedSearchResult[]): Promise<void> {\n    for (const r of results) {\n      const photo = this.database.getPhotoByUuid(r.photoUuid)\n      if (photo) {\n        r.thumbnailPath = photo.thumbnail_path\n        r.takenAt = photo.taken_at\n      }\n    }\n  }\n\n  /**\n   * 重新排序结果\n   */\n  reorderResults(\n    results: MergedSearchResult[],\n    sortBy: 'keyword' | 'semantic' | 'mixed' | 'recency'\n  ): MergedSearchResult[] {\n    const sorted = [...results]\n\n    switch (sortBy) {\n      case 'keyword':\n        sorted.sort((a, b) => {\n          const aKeyword = a.sources.find(s => s.type === 'keyword')?.weightedScore || 0\n          const bKeyword = b.sources.find(s => s.type === 'keyword')?.weightedScore || 0\n          return bKeyword - aKeyword\n        })\n        break\n\n      case 'semantic':\n        sorted.sort((a, b) => {\n          const aSemantic = a.sources.find(s => s.type === 'semantic')?.weightedScore || 0\n          const bSemantic = b.sources.find(s => s.type === 'semantic')?.weightedScore || 0\n          return bSemantic - aSemantic\n        })\n        break\n\n      case 'recency':\n        sorted.sort((a, b) => {\n          const dateA = a.takenAt ? new Date(a.takenAt).getTime() : 0\n          const dateB = b.takenAt ? new Date(b.takenAt).getTime() : 0\n          return dateB - dateA\n        })\n        break\n\n      case 'mixed':\n      default:\n        sorted.sort((a, b) => b.score - a.score)\n    }\n\n    // 更新排名\n    sorted.forEach((r, i) => r.rank = i + 1)\n    return sorted\n  }\n\n  /**\n   * 获取结果统计\n   */\n  getStats(results: MergedSearchResult[]): {\n    total: number\n    withBothSources: number\n    keywordOnly: number\n    semanticOnly: number\n    avgScore: number\n  } {\n    let withBothSources = 0\n    let keywordOnly = 0\n    let semanticOnly = 0\n    let totalScore = 0\n\n    for (const r of results) {\n      const hasKeyword = r.sources.some(s => s.type === 'keyword')\n      const hasSemantic = r.sources.some(s => s.type === 'semantic')\n\n      if (hasKeyword && hasSemantic) {\n        withBothSources++\n      } else if (hasKeyword) {\n        keywordOnly++\n      } else if (hasSemantic) {\n        semanticOnly++\n      }\n\n      totalScore += r.score\n    }\n\n    return {\n      total: results.length,\n      withBothSources,\n      keywordOnly,\n      semanticOnly,\n      avgScore: results.length > 0 ? totalScore / results.length : 0\n    }\n  }\n}\n\nexport const resultMergeService = new ResultMergeService()\n"],"names":[],"mappings":"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"}
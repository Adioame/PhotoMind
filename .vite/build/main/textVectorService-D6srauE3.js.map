{"version":3,"file":"textVectorService-D6srauE3.js","sources":["../../../electron/services/textVectorService.ts"],"sourcesContent":["/**\n * PhotoMind - 文本向量服务\n *\n * 功能：\n * 1. 文本转向量\n * 2. 向量缓存管理\n * 3. 批量处理\n */\nimport { getEmbeddingService } from './embeddingService.js'\nimport type { EmbeddingVector, EmbeddingResult } from '../types/embedding.js'\n\ninterface TextVectorCache {\n  query: string\n  vector: EmbeddingVector\n  timestamp: number\n}\n\nexport interface SearchQueryResult {\n  query: string\n  vector: EmbeddingVector | null\n  processingTimeMs: number\n  fromCache: boolean\n}\n\nexport class TextVectorService {\n  private cache: Map<string, TextVectorCache> = new Map()\n  private cacheMaxAge = 5 * 60 * 1000 // 5分钟\n  private maxCacheSize = 1000\n\n  /**\n   * 将文本转换为向量\n   */\n  async textToVector(text: string): Promise<SearchQueryResult> {\n    const startTime = Date.now()\n\n    // 检查缓存\n    const cached = this.getCachedVector(text)\n    if (cached) {\n      console.log('[TextVector] 使用缓存的向量')\n      return {\n        query: text,\n        vector: cached,\n        processingTimeMs: 0,\n        fromCache: true\n      }\n    }\n\n    // 生成向量\n    const embeddingService = getEmbeddingService()\n    const result = await embeddingService.textToEmbedding(text)\n\n    // 缓存结果\n    if (result.success && result.vector) {\n      this.cacheVector(text, result.vector)\n    }\n\n    return {\n      query: text,\n      vector: result.vector || null,\n      processingTimeMs: result.processingTimeMs,\n      fromCache: false\n    }\n  }\n\n  /**\n   * 批量处理多个搜索文本\n   */\n  async textsToVectors(\n    texts: string[]\n  ): Promise<Map<string, SearchQueryResult>> {\n    const results = new Map<string, SearchQueryResult>()\n\n    for (const text of texts) {\n      const result = await this.textToVector(text)\n      results.set(text, result)\n    }\n\n    return results\n  }\n\n  /**\n   * 处理搜索查询（预处理 + 转向量）\n   */\n  async processQuery(\n    text: string,\n    preprocess: (text: string) => { processed: string; keywords: string[]; language: string }\n  ): Promise<SearchQueryResult & { processed: string; keywords: string[]; language: string }> {\n    const startTime = Date.now()\n\n    // 预处理\n    const processed = preprocess(text)\n\n    // 检查缓存（使用原始文本）\n    const cached = this.getCachedVector(text)\n    if (cached) {\n      return {\n        query: text,\n        vector: cached,\n        processingTimeMs: 0,\n        fromCache: true,\n        processed: processed.processed,\n        keywords: processed.keywords,\n        language: processed.language\n      }\n    }\n\n    // 生成向量\n    const embeddingService = getEmbeddingService()\n    const result = await embeddingService.textToEmbedding(processed.processed)\n\n    // 缓存结果\n    if (result.success && result.vector) {\n      this.cacheVector(text, result.vector)\n    }\n\n    return {\n      query: text,\n      vector: result.vector || null,\n      processingTimeMs: result.processingTimeMs,\n      fromCache: false,\n      processed: processed.processed,\n      keywords: processed.keywords,\n      language: processed.language\n    }\n  }\n\n  /**\n   * 获取缓存的向量\n   */\n  private getCachedVector(query: string): EmbeddingVector | null {\n    const cached = this.cache.get(query)\n    if (!cached) return null\n\n    // 检查是否过期\n    if (Date.now() - cached.timestamp > this.cacheMaxAge) {\n      this.cache.delete(query)\n      return null\n    }\n\n    return cached.vector\n  }\n\n  /**\n   * 缓存向量\n   */\n  private cacheVector(query: string, vector: EmbeddingVector): void {\n    // 清理过期缓存\n    if (this.cache.size >= this.maxCacheSize) {\n      this.cleanExpiredCache()\n    }\n\n    this.cache.set(query, {\n      query,\n      vector,\n      timestamp: Date.now()\n    })\n  }\n\n  /**\n   * 清理过期缓存\n   */\n  private cleanExpiredCache(): void {\n    const now = Date.now()\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.cacheMaxAge) {\n        this.cache.delete(key)\n      }\n    }\n  }\n\n  /**\n   * 清空缓存\n   */\n  clearCache(): void {\n    this.cache.clear()\n    console.log('[TextVector] 缓存已清空')\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getCacheStats(): { size: number; maxSize: number; hitRate?: number } {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxCacheSize\n    }\n  }\n\n  /**\n   * 设置缓存过期时间\n   */\n  setCacheMaxAge(minutes: number): void {\n    this.cacheMaxAge = minutes * 60 * 1000\n  }\n\n  /**\n   * 设置最大缓存大小\n   */\n  setMaxCacheSize(size: number): void {\n    this.maxCacheSize = size\n  }\n}\n\nexport const textVectorService = new TextVectorService()\n"],"names":[],"mappings":"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"}